<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>NoiseCraft Global Audio Workspace</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/public/style.css" />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #111;
        color: #eee;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        overflow: hidden;
      }
      .header {
        padding: 12px 16px;
        background: #1a1a1a;
        border-bottom: 1px solid #333;
        display: flex;
        gap: 12px;
        align-items: center;
      }
      button {
        background: #333;
        color: #fff;
        border: 1px solid #444;
        border-radius: 6px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 13px;
      }
      button:hover {
        background: #3a3a3a;
      }
      button.danger {
        background: #5a1a1a;
      }
      button.danger:hover {
        background: #6a2a2a;
      }
      .status {
        opacity: 0.8;
        font-size: 12px;
        color: #aaa;
        margin-left: auto;
      }
      .main-content {
        display: flex;
        flex: 1;
        overflow: hidden;
      }
      .left-panel {
        width: 360px;
        background: #1a1a1a;
        border-right: 1px solid #333;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      .left-panel-tabs {
        display: flex;
        background: #222;
        border-bottom: 1px solid #333;
      }
      .tab {
        flex: 1;
        padding: 10px;
        text-align: center;
        cursor: pointer;
        font-size: 12px;
        border-right: 1px solid #333;
        background: #222;
        color: #aaa;
      }
      .tab.active {
        background: #1a1a1a;
        color: #fff;
      }
      .tab-content {
        flex: 1;
        overflow-y: auto;
        padding: 16px;
        display: none;
        flex-direction: column;
        gap: 16px;
        position: relative;
        z-index: 1;
      }
      .tab-content.active {
        display: flex;
      }
      .panel-section {
        background: #222;
        padding: 12px;
        border-radius: 6px;
      }
      .panel-section h3 {
        font-size: 13px;
        margin-bottom: 12px;
        color: #fff;
      }
      .param-row {
        display: flex;
        justify-content: space-between;
        margin: 6px 0;
        font-size: 11px;
      }
      .param-label {
        color: #aaa;
      }
      .param-value {
        color: #fff;
        font-weight: 500;
        font-family: "Courier New", monospace;
      }
      .right-panel {
        flex: 1;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }
      #noisecraft-container {
        flex: 1;
        overflow: hidden;
      }
      #noisecraft-iframe {
        width: 100%;
        height: 100%;
        border: none;
      }
      .slider-group {
        margin: 12px 0;
      }
      .slider-label {
        font-size: 11px;
        color: #aaa;
        margin-bottom: 6px;
        display: flex;
        justify-content: space-between;
      }
      input[type="range"] {
        width: 100%;
        accent-color: #4a9eff;
      }
      input[type="number"],
      input[type="text"],
      select {
        background: #2a2a2a;
        color: #fff;
        border: 1px solid #444;
        padding: 4px 6px;
        border-radius: 4px;
        font-size: 11px;
        pointer-events: auto;
        cursor: text;
        border: 1px solid #444;
        border-radius: 4px;
        padding: 4px 8px;
        font-size: 11px;
        width: 100%;
      }
      select {
        cursor: pointer;
      }
      .info-text {
        font-size: 10px;
        color: #666;
        line-height: 1.4;
        margin-top: 8px;
      }
      .mapping-item {
        background: #1a1a1a;
        border: 1px solid #333;
        border-radius: 6px;
        padding: 12px;
        margin-bottom: 12px;
        position: relative;
        z-index: 2;
        pointer-events: auto;
      }
      .mapping-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
      }
      .mapping-header h4 {
        font-size: 12px;
        color: #fff;
      }
      .mapping-controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .control-row {
        display: grid;
        grid-template-columns: 80px 1fr;
        gap: 8px;
        align-items: center;
        font-size: 11px;
      }
      .control-label {
        color: #aaa;
        text-align: right;
      }
      .stream-input-group {
        display: flex;
        gap: 4px;
        align-items: center;
      }
      .stream-input-group select,
      .stream-input-group input {
        flex: 1;
        pointer-events: auto;
        cursor: text;
      }
      .stream-input-group select {
        cursor: pointer;
      }
      .mapping-controls input,
      .mapping-controls select {
        pointer-events: auto;
        cursor: text;
        background: #2a2a2a;
        border: 1px solid #444;
        color: #fff;
        padding: 4px 6px;
        border-radius: 4px;
        font-size: 11px;
      }
      .mapping-controls select {
        cursor: pointer;
      }
      .mapping-controls input:hover,
      .mapping-controls select:hover {
        border-color: #555;
      }
      .mapping-controls input:focus,
      .mapping-controls select:focus {
        outline: none;
        border-color: #4a8;
      }
      .operation-select {
        width: 80px;
      }
      .add-stream-btn {
        width: 100%;
        margin-top: 8px;
        padding: 6px;
        font-size: 11px;
      }
      .remove-btn {
        padding: 4px 8px;
        font-size: 10px;
        background: #5a1a1a;
      }
      .range-inputs {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 4px;
      }
      .add-mapping-btn {
        width: 100%;
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <div class="header">
      <button id="btn_start">▶ Start Audio</button>
      <button id="btn_stop" style="display: none">⏹ Stop</button>
      <div class="status" id="status">Loading...</div>
    </div>

    <div class="main-content">
      <div class="left-panel">
        <div class="left-panel-tabs">
          <div class="tab active" data-tab="signals">Signals</div>
          <div class="tab" data-tab="mappings">Mappings</div>
        </div>

        <div class="tab-content active" id="signals-tab">
          <div class="panel-section">
            <h3>Signal Streams - Particle 0</h3>
            <div id="signal-info-0">
              <div class="param-row">
                <span class="param-label">Attraction:</span>
                <span class="param-value" id="signal-attraction-0">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Velocity:</span>
                <span class="param-value" id="signal-velocity-0">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Distance:</span>
                <span class="param-value" id="signal-distance-0">∞</span>
              </div>
              <div class="param-row">
                <span class="param-label">Closing Speed:</span>
                <span class="param-value" id="signal-closing-0">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Inner:</span>
                <span class="param-value" id="signal-inner-0">false</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Outer:</span>
                <span class="param-value" id="signal-outer-0">false</span>
              </div>
            </div>
            <div class="scope-container" style="margin-top: 12px;">
              <canvas id="scope-attraction-0" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block; margin-bottom: 4px;"></canvas>
              <canvas id="scope-velocity-0" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block;"></canvas>
            </div>
          </div>
          
          <div class="panel-section">
            <h3>Signal Streams - Particle 1</h3>
            <div id="signal-info-1">
              <div class="param-row">
                <span class="param-label">Attraction:</span>
                <span class="param-value" id="signal-attraction-1">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Velocity:</span>
                <span class="param-value" id="signal-velocity-1">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Distance:</span>
                <span class="param-value" id="signal-distance-1">∞</span>
              </div>
              <div class="param-row">
                <span class="param-label">Closing Speed:</span>
                <span class="param-value" id="signal-closing-1">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Inner:</span>
                <span class="param-value" id="signal-inner-1">false</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Outer:</span>
                <span class="param-value" id="signal-outer-1">false</span>
              </div>
            </div>
            <div class="scope-container" style="margin-top: 12px;">
              <canvas id="scope-attraction-1" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block; margin-bottom: 4px;"></canvas>
              <canvas id="scope-velocity-1" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block;"></canvas>
            </div>
          </div>
          
          <div class="panel-section">
            <h3>Signal Streams - Particle 2</h3>
            <div id="signal-info-2">
              <div class="param-row">
                <span class="param-label">Attraction:</span>
                <span class="param-value" id="signal-attraction-2">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Velocity:</span>
                <span class="param-value" id="signal-velocity-2">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Distance:</span>
                <span class="param-value" id="signal-distance-2">∞</span>
              </div>
              <div class="param-row">
                <span class="param-label">Closing Speed:</span>
                <span class="param-value" id="signal-closing-2">0.00</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Inner:</span>
                <span class="param-value" id="signal-inner-2">false</span>
              </div>
              <div class="param-row">
                <span class="param-label">Is Outer:</span>
                <span class="param-value" id="signal-outer-2">false</span>
              </div>
            </div>
            <div class="scope-container" style="margin-top: 12px;">
              <canvas id="scope-attraction-2" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block; margin-bottom: 4px;"></canvas>
              <canvas id="scope-velocity-2" width="320" height="60" style="width: 100%; height: 60px; background: #111; border: 1px solid #333; display: block;"></canvas>
            </div>
          </div>

          <div class="panel-section">
            <h3>Interaction Radii</h3>
            <div class="slider-group">
              <div class="slider-label">
                <span>Inner (Distinct)</span>
                <span class="param-value" id="inner-radius-value">80</span>
              </div>
              <input
                type="range"
                id="inner-radius"
                min="40"
                max="120"
                value="80"
              />
            </div>
            <div class="slider-group">
              <div class="slider-label">
                <span>Outer (React)</span>
                <span class="param-value" id="outer-radius-value">150</span>
              </div>
              <input
                type="range"
                id="outer-radius"
                min="100"
                max="250"
                value="150"
              />
            </div>
          </div>

          <div class="panel-section">
            <h3>Gravitational Force</h3>
            <div class="slider-group">
              <div class="slider-label">
                <span>G (Strength)</span>
                <span class="param-value" id="g-value">100</span>
              </div>
              <input
                type="range"
                id="g-constant"
                min="10"
                max="500"
                value="100"
              />
            </div>
            <div class="slider-group">
              <div class="slider-label">
                <span>Min Distance</span>
                <span class="param-value" id="min-dist-value">10</span>
              </div>
              <input
                type="range"
                id="min-distance"
                min="1"
                max="50"
                value="10"
              />
            </div>
          </div>
          
          <div class="panel-section">
            <h3>Particle Visualization (Global View)</h3>
            <canvas id="particle-canvas" width="320" height="320" style="width: 100%; height: 320px; background: #0a0a0a; border: 1px solid #333; display: block; cursor: default;"></canvas>
            <div style="margin-top: 8px; font-size: 11px; color: #aaa;">
              <div>Particles: <span id="particle-count">3</span></div>
              <div>Fixed view centered on center of mass</div>
            </div>
          </div>
          
          <div class="panel-section">
            <h3>Individual View (Moon 1)</h3>
            <canvas id="individual-canvas" width="320" height="320" style="width: 100%; height: 320px; background: #0a0a0a; border: 1px solid #333; display: block; cursor: crosshair;"></canvas>
            <div style="margin-top: 8px; font-size: 11px; color: #aaa;">
              <div>Viewing from: <span id="viewed-particle">P1</span></div>
              <div>Drag from center to control velocity</div>
            </div>
          </div>
        </div>

        <div class="tab-content" id="mappings-tab">
          <div class="panel-section">
            <h3>Stream → Node Mappings</h3>
            <div id="mappings-container"></div>
            <div style="display: flex; gap: 8px; margin-top: 8px;">
              <button class="add-mapping-btn" id="add-mapping-btn">
                + Add Mapping
              </button>
              <button class="add-mapping-btn" id="export-mappings-btn" style="flex: 1;">
                Export Mappings
              </button>
              <button class="add-mapping-btn" id="import-mappings-btn" style="flex: 1;">
                Import Mappings
              </button>
              <input type="file" id="import-file-input" accept=".json" style="display: none;">
            </div>
          </div>
        </div>
      </div>

      <div class="right-panel">
        <div id="noisecraft-container">
          <iframe
            id="noisecraft-iframe"
            src="/public/embedded.html?src=/public/examples/glb_audio_map.ncft"
          ></iframe>
        </div>
      </div>
    </div>

    <script type="module">
      // Import particle system module
      import { VirtualParticle, SignalGenerator, ParticleSystem } from '/public/particle-system.js';
      import { SequencerLogic, convertNotePatternToNoiseCraft, updateMonoSeqSequencer } from '/public/sequencer-logic.js';
      import { processBackgroundAudio, calculateLocalization } from '/public/background-audio-post-processing.js';
      import { SpatialAudioProcessor, createSpatialProcessor } from '/public/spatial-audio-processor.js';
      import { generateHarmoniousPattern, generateHarmonizingPattern, generateChordPatterns, SCALES, CHORD_TONES, getRandomScale } from '/public/music-theory.js';
      // Import new modular components
      import { createPatternAssignmentManager } from '/public/pattern-assignment.js';
      import { createMappingStorage } from '/public/mapping-storage.js';
      
      console.log("[Init] ===== SCRIPT STARTING =====");
      console.log("[Init] All imports loaded successfully");
      
      // Dummy storage fallback if mapping-storage.js is not available
      function createDummyStorage() {
        return {
          loadMappings: () => [],
          saveToLocalStorage: () => {},
          loadFromLocalStorage: () => [],
          exportAsJSON: () => {},
          importFromJSON: () => Promise.resolve([]),
          saveToProjectFile: (data, mappings) => data,
          loadFromProjectFile: (data) => []
        };
      }
      
      // Wrap main code in try-catch to catch initialization errors
      try {
        console.log("[Init] Entering try block...");

      console.log("[Init] Defining AVAILABLE_STREAMS...");
      // Available streams
      const AVAILABLE_STREAMS = [
        "attraction",
        "velocity",
        "distance",
        "closingSpeed",
        "isInner",
        "isOuter",
      ];

      // Interpolation modes
      const INTERPOLATION_MODES = ["linear", "logarithmic", "exponential"];

      // Mathematical operations
      const OPERATIONS = [
        { value: "none", label: "None" },
        { value: "add", label: "Add (+)" },
        { value: "subtract", label: "Subtract (-)" },
        { value: "multiply", label: "Multiply (×)" },
        { value: "divide", label: "Divide (÷)" },
        { value: "min", label: "Min" },
        { value: "max", label: "Max" },
        { value: "average", label: "Average" },
      ];

      console.log("[Init] Defining StreamNodeMapper class...");
      // Stream-to-Node Mapping Manager (now uses MappingStorage module)
      class StreamNodeMapper {
        constructor(filename = 'glb_audio_map.ncft') {
          this.mappings = [];
          this.filename = filename;
          this.storage = createMappingStorage(filename);
          this.loadMappings();
        }

        async loadMappings() {
          try {
            // Try loading from project file first, then localStorage
            const response = await fetch(`/public/examples/${this.filename}`);
            if (response.ok) {
              const projectData = await response.json();
              this.mappings = await this.storage.loadMappings(projectData);
              if (this.mappings.length > 0) {
                console.log(`[MappingStorage] Loaded ${this.mappings.length} mappings from project file`);
              }
            }
            
            // If no project mappings, fallback to localStorage
            if (this.mappings.length === 0) {
              this.mappings = this.storage.loadFromLocalStorage();
              if (this.mappings.length > 0) {
                console.log(`[MappingStorage] Loaded ${this.mappings.length} mappings from localStorage`);
              }
            }
          } catch (e) {
            console.warn("Failed to load mappings, using localStorage:", e);
            this.mappings = this.storage.loadFromLocalStorage();
          }
        }

        saveToStorage() {
          // Save to localStorage (always)
          this.storage.saveToLocalStorage(this.mappings);
        }
        
        async saveToProjectFile(projectData) {
          // Save mappings to project file metadata
          const updatedProject = this.storage.saveToProjectFile(projectData, this.mappings);
          return updatedProject;
        }
        
        exportMappings() {
          const filename = `mappings-${this.filename.replace('.ncft', '')}-${new Date().toISOString().split('T')[0]}.json`;
          this.storage.exportAsJSON(this.mappings, filename);
        }
        
        async importMappings(file) {
          try {
            const imported = await this.storage.importFromJSON(file);
            this.mappings = imported;
            this.saveToStorage();
            console.log(`[MappingStorage] Imported ${imported.length} mappings`);
            return true;
          } catch (e) {
            console.error('Failed to import mappings:', e);
            return false;
          }
        }

        addMapping(mapping) {
          const id = Date.now().toString();
          this.mappings.push({ ...mapping, id });
          this.saveToStorage();
          return id;
        }

        removeMapping(id) {
          this.mappings = this.mappings.filter((m) => m.id !== id);
          this.saveToStorage();
        }

        updateMapping(id, updates) {
          const index = this.mappings.findIndex((m) => m.id === id);
          if (index !== -1) {
            this.mappings[index] = { ...this.mappings[index], ...updates };
            this.saveToStorage();
          }
        }

        // Apply interpolation
        interpolate(value, mode, inputMin, inputMax, outputMin, outputMax) {
          // Clamp and normalize
          const normalized = Math.max(
            0,
            Math.min(1, (value - inputMin) / (inputMax - inputMin || 1))
          );
          let transformed = normalized;

          if (mode === "logarithmic") {
            transformed = Math.log(normalized * 9 + 1) / Math.log(10);
          } else if (mode === "exponential") {
            transformed = (Math.pow(10, normalized) - 1) / 9;
          }

          return outputMin + transformed * (outputMax - outputMin);
        }

        // Compute final value for a mapping
        computeMappingValue(mapping, signals) {
          const streamValues = mapping.streams.map((streamConfig) => {
            const streamValue = signals[streamConfig.stream];
            if (streamValue === undefined || streamValue === null) return 0;

            return this.interpolate(
              streamValue,
              streamConfig.interpolation || "linear",
              streamConfig.inputMin || 0,
              streamConfig.inputMax || 1,
              streamConfig.outputMin || 0,
              streamConfig.outputMax || 1
            );
          });

          // Apply mathematical operations
          if (streamValues.length === 0) return null;
          if (streamValues.length === 1) return streamValues[0];

          const op = mapping.operation || "none";
          
          // If operation is "none", use only the first stream
          if (op === "none") {
            return streamValues[0];
          }

          // Apply operation to all streams
          let result = streamValues[0];
          for (let i = 1; i < streamValues.length; i++) {
            const nextValue = streamValues[i];

            if (op === "add") {
              result += nextValue;
            } else if (op === "subtract") {
              result -= nextValue;
            } else if (op === "multiply") {
              result *= nextValue;
            } else if (op === "divide") {
              // Avoid division by zero
              result = nextValue !== 0 ? result / nextValue : result;
            } else if (op === "min") {
              result = Math.min(result, nextValue);
            } else if (op === "max") {
              result = Math.max(result, nextValue);
            } else if (op === "average") {
              // Calculate running average correctly
              result = (result * i + nextValue) / (i + 1);
            }
          }

          // Debug logging for multiple stream operations
          if (streamValues.length > 1 && op !== "none") {
            console.log(`[StreamMapper] Operation: ${op}, Streams: ${streamValues.length}, Result: ${result.toFixed(4)}`);
          }

          return result;
        }

        // Generate all parameter updates from mappings
        generateParams(signals) {
          const params = [];
          for (const mapping of this.mappings) {
            if (!mapping.enabled) continue;

            const value = this.computeMappingValue(mapping, signals);
            if (value === null || value === undefined) continue;

            params.push({
              nodeId: String(mapping.nodeId),
              paramName: mapping.paramName || "value",
              value: Number(value),
            });
          }
          return params;
        }
      }

      console.log("[Init] ===== STARTING PARTICLE INITIALIZATION =====");
      // Create particle system (standalone module)
      // Note: innerRadius/outerRadius are ONLY for signal generation (sound effects)
      // Gravity works at ALL distances regardless of these radii
      console.log("[Particle Init] Step 1: Creating ParticleSystem...");
      let particleSystem;
      try {
        particleSystem = new ParticleSystem({
          innerRadius: 80,    // Distinct range: audio + visual feedback
          outerRadius: 150,   // Outer range: audio cue only (orientation + distance)
          G: 500,             // Realistic gravitational constant (reduced from 10000)
          minDistance: 3,     // Minimum distance for numerical stability
        });
        console.log("[Particle Init] ✓ ParticleSystem created:", particleSystem);
        console.log("[Particle Init]   signalGenerator:", particleSystem?.signalGenerator);
        console.log("[Particle Init]   signalGenerator.particles:", particleSystem?.signalGenerator?.particles);
      } catch (e) {
        console.error("[Particle Init] ✗ Failed to create ParticleSystem:", e);
        throw e;
      }

      // Initialize modular pattern assignment manager
      console.log("[Particle Init] Step 2: Creating pattern manager...");
      let patternManager;
      try {
        patternManager = createPatternAssignmentManager({
          mode: 'individual',
          key: 'C',
          scale: 'major'
        });
        console.log("[Particle Init] ✓ Pattern manager created");
      } catch (e) {
        console.error("[Particle Init] ✗ Failed to create pattern manager:", e);
        // Continue without pattern manager - particles can still be created
      }
      
      // Expose music theory functions globally for pattern manager fallback
      window.generateHarmoniousPattern = generateHarmoniousPattern;
      window.generateHarmonizingPattern = generateHarmonizingPattern;
      
      // Current scale for music theory
      const availableScales = Object.keys(SCALES);
      const randomScaleIndex = Math.floor(Math.random() * availableScales.length);
      let currentScale = availableScales[randomScaleIndex];
      console.log(`[Music Theory] Using scale: ${currentScale} (randomized for variety)`);
      
      // Create a stable 3-body system: One central particle with 2 orbiting moons
      // Using more realistic mass ratios so all particles stay visible
      const centerX = 575;
      const centerY = 525;
      
      // Central particle - reduced mass so it moves more visibly
      const centralMass = 100; // Reduced from 500 - allows visible interaction
      
      console.log("[Particle Init] Step 3: Adding particles...");
      
      // Generate initial chord using modular pattern manager
      const defaultTriad = 'C Major'; // [0, 4, 7] = C, E, G
      const chordTones = CHORD_TONES[defaultTriad];
      
      // Two "moon" particles with similar mass to central for visible interaction
      const moonMass = 50; // Closer to central mass ratio
      const moonDistance = 100; // Increased distance for better visibility
      
      let particle0, particle1, particle2;
      try {
        console.log("[Particle Init]   Adding particle 0...");
        particle0 = particleSystem.addParticle(0, centerX, centerY, 0, centralMass);
        console.log("[Particle Init]   ✓ Particle 0 added:", particle0);
        console.log("[Particle Init]   Current particles:", particleSystem.getParticles().length);
        
        const createPatternFromNote = (noteIndex) => {
          const pattern = new Array(12).fill(0);
          pattern[noteIndex % 12] = 1;
          return pattern;
        };
        
        // Assign triad tones directly: Root, Third, Fifth
        particle0.sequencerPattern = createPatternFromNote(chordTones[0]); // C (root)
        if (patternManager) {
          patternManager.assignPattern(0, particle0.sequencerPattern);
        }
        
        console.log("[Particle Init]   Adding particle 1...");
        particle1 = particleSystem.addParticle(1, centerX + moonDistance, centerY, 4, moonMass);
        console.log("[Particle Init]   ✓ Particle 1 added:", particle1);
        console.log("[Particle Init]   Current particles:", particleSystem.getParticles().length);
        
        particle1.sequencerPattern = createPatternFromNote(chordTones[1]); // E (third)
        if (patternManager) {
          patternManager.assignPattern(1, particle1.sequencerPattern);
        }
        
        console.log("[Particle Init]   Adding particle 2...");
        particle2 = particleSystem.addParticle(2, centerX, centerY - moonDistance, 7, moonMass);
        console.log("[Particle Init]   ✓ Particle 2 added:", particle2);
        console.log("[Particle Init]   Current particles:", particleSystem.getParticles().length);
        
        particle2.sequencerPattern = createPatternFromNote(chordTones[2]); // G (fifth)
        if (patternManager) {
          patternManager.assignPattern(2, particle2.sequencerPattern);
        }
        
        console.log("[Particle Init] ✓ All 3 particles added successfully");
      } catch (e) {
        console.error("[Particle Init] ✗ Failed to add particles:", e);
        console.error("[Particle Init]   Error stack:", e.stack);
        throw e;
      }
      
      // Verify the triad was assigned correctly
      const assignedNotes = {
        particle0: particle0.sequencerPattern.findIndex(v => v === 1),
        particle1: particle1.sequencerPattern.findIndex(v => v === 1),
        particle2: particle2.sequencerPattern.findIndex(v => v === 1),
      };
      console.log('✓ Initial triad assigned:', assignedNotes);
      console.log('  Expected:', chordTones);

      // Set velocities for stable orbital motion
      // Central particle starts with small velocity (will move due to lighter mass)
      particle0.velocity = { x: 0, y: 0 };
      
      // Calculate orbital velocities for moons around central particle
      // For circular orbit: v = sqrt(G*M_central/r)
      // Using 70% of circular velocity for stable elliptical orbits (all particles visible)
      const G = 500;
      const centralMassForOrbit = centralMass; // centralMass is defined above (line ~791)
      
      // Moon 1: Orbital velocity (counter-clockwise)
      const r1 = moonDistance;
      const v1 = Math.sqrt(G * centralMassForOrbit / r1) * 0.7;
      particle1.velocity = { x: 0, y: v1 }; // Tangential to orbit
      
      // Moon 2: Orbital velocity (counter-clockwise, perpendicular to moon 1)
      const r2 = moonDistance;
      const v2 = Math.sqrt(G * centralMassForOrbit / r2) * 0.7;
      particle2.velocity = { x: -v2, y: 0 }; // Tangential to orbit

      // Get particles and signal generator for backward compatibility
      const particles = particleSystem.getParticles();
      const signalGenerator = particleSystem.signalGenerator;
      
      // Initialize sequencer logic
      const sequencerLogic = new SequencerLogic();
      
      // Sequencer node IDs from glb_audio_map.ncft
      const SEQUENCER_NODES = {
        individual: {
          bass: "211",      // MonoSeq "bass"
          baritone: "212",  // MonoSeq "baritone"
          tenor: "213"      // MonoSeq "tenor"
        }
      };
      
      // Track previous inner particle state to detect changes
      let previousInnerParticleIds = new Set();
      let previousSequencerPattern = null;
      
      // Debug: Verify particles are created and log note profiles
      console.log(`Particle system initialized with ${particles.length} particles:`, particles);
      console.log('Particle positions:', particles.map(p => ({ id: p.id, x: p.position.x, y: p.position.y })));
      console.log('Particle note profiles:', {
        0: particle0.sequencerPattern,
        1: particle1.sequencerPattern,
        2: particle2.sequencerPattern,
        activeNotes: {
          0: particle0.getActiveNoteIndex(),
          1: particle1.getActiveNoteIndex(),
          2: particle2.getActiveNoteIndex()
        }
      });
      
      // Verify particle system is working
      if (particles.length === 0) {
        console.error("CRITICAL: No particles were created!");
        console.error("  particleSystem:", particleSystem);
        console.error("  signalGenerator:", particleSystem?.signalGenerator);
        console.error("  signalGenerator.particles:", particleSystem?.signalGenerator?.particles);
        console.error("  getParticles() returned:", particles);
        
        // Emergency reinitialize if needed
        console.warn("⚠️ Attempting emergency particle reinitialization...");
        try {
          const emergency0 = particleSystem.addParticle(0, centerX, centerY, 0, centralMass);
          const emergency1 = particleSystem.addParticle(1, centerX + moonDistance, centerY, 4, moonMass);
          const emergency2 = particleSystem.addParticle(2, centerX, centerY - moonDistance, 7, moonMass);
          const emergencyParticles = particleSystem.getParticles();
          console.log(`Emergency reinit result: ${emergencyParticles.length} particles`);
        } catch (e) {
          console.error("Emergency reinit failed:", e);
        }
      } else {
        console.log("✓ Particles initialized successfully, starting animation loop");
        // Double-check particles are accessible
        const verifyParticles = particleSystem.getParticles();
        if (verifyParticles.length !== particles.length) {
          console.warn(`⚠️ Particle count mismatch: initialized ${particles.length}, getParticles() returned ${verifyParticles.length}`);
        }
      }
      
      // Expose particle system globally for integration
      window.particleSystem = particleSystem;
      window.sequencerLogic = sequencerLogic;
      
      // Audio localization helper - DEPRECATED: Use background-audio-post-processing.js module instead
      // Kept for backwards compatibility only
      window.audioLocalization = {
        calculateLocalization: calculateLocalization
      };
      
      // ===== SPATIAL AUDIO PROCESSOR (Web Audio API Post-Processing) =====
      // Web Audio API를 사용한 정교한 spatialization 적용
      // NoiseCraft 오디오 출력을 받아서 PannerNode로 공간 오디오 처리
      
      let spatialProcessor = null;
      // NoiseCraft integration - declare iframe early for audio stream access
      const iframe = document.getElementById("noisecraft-iframe");
      
      let spatialAudioContext = null;
      let mediaStreamSource = null; // MediaStreamAudioSourceNode from NoiseCraft
      let isSpatialAudioEnabled = false;
      
      // Initialize Spatial Audio Processor when audio stream is available
      function initializeSpatialProcessor(mediaStream, sampleRate) {
        try {
          // Create or reuse AudioContext
          if (!spatialAudioContext) {
            spatialAudioContext = new AudioContext({
              latencyHint: 'interactive',
              sampleRate: sampleRate || 44100
            });
          }
          
          // Resume context if suspended (browser autoplay policy)
          if (spatialAudioContext.state === 'suspended') {
            spatialAudioContext.resume();
          }
          
          // Create MediaStreamAudioSourceNode from the stream
          if (mediaStreamSource) {
            mediaStreamSource.disconnect();
          }
          mediaStreamSource = spatialAudioContext.createMediaStreamSource(mediaStream);
          
          // Create spatial processor
          const config = particleSystem.getConfig();
          spatialProcessor = createSpatialProcessor(spatialAudioContext, {
            innerRadius: config.innerRadius || 80,
            outerRadius: config.outerRadius || 150
          });
          
          // Immediately set up audio processing pipeline
          // This ensures audio plays even when no particles are nearby (self audio)
          window.stereoPanner = spatialAudioContext.createStereoPanner();
          window.distanceGain = spatialAudioContext.createGain();
          
          // Create reverb effect for background audio (other users' sounds)
          // Using delay-based reverb (ConvolverNode would require impulse response)
          window.reverbGain = spatialAudioContext.createGain();
          window.reverbDelay1 = spatialAudioContext.createDelay(0.1);
          window.reverbDelay2 = spatialAudioContext.createDelay(0.08);
          window.reverbDelay3 = spatialAudioContext.createDelay(0.06);
          window.reverbFeedback1 = spatialAudioContext.createGain();
          window.reverbFeedback2 = spatialAudioContext.createGain();
          window.reverbFeedback3 = spatialAudioContext.createGain();
          window.reverbMix = spatialAudioContext.createGain(); // Controls reverb wetness
          
          // Set up reverb feedback loop
          window.reverbFeedback1.gain.value = 0.3;
          window.reverbFeedback2.gain.value = 0.25;
          window.reverbFeedback3.gain.value = 0.2;
          window.reverbMix.gain.value = 0; // Start with no reverb (self audio)
          
          // Reverb routing: input -> delays -> feedback -> mix
          window.reverbDelay1.delayTime.value = 0.05; // 50ms
          window.reverbDelay2.delayTime.value = 0.035; // 35ms
          window.reverbDelay3.delayTime.value = 0.025; // 25ms
          
          // Route: NoiseCraft MediaStream -> StereoPanner -> [Dry + Reverb] -> Gain -> Destination
          // Dry path (self audio): StereoPanner -> Gain
          // Wet path (background audio): StereoPanner -> Reverb -> Mix -> Gain
          mediaStreamSource.connect(window.stereoPanner);
          
          // Dry signal (self audio - no reverb)
          window.stereoPanner.connect(window.distanceGain);
          
          // Wet signal (background audio - with reverb)
          // Create parallel reverb processing
          const reverbInput = spatialAudioContext.createGain();
          window.stereoPanner.connect(reverbInput);
          reverbInput.connect(window.reverbDelay1);
          reverbInput.connect(window.reverbDelay2);
          reverbInput.connect(window.reverbDelay3);
          
          // Reverb feedback loops
          window.reverbDelay1.connect(window.reverbFeedback1);
          window.reverbDelay2.connect(window.reverbFeedback2);
          window.reverbDelay3.connect(window.reverbFeedback3);
          window.reverbFeedback1.connect(window.reverbDelay1);
          window.reverbFeedback2.connect(window.reverbDelay2);
          window.reverbFeedback3.connect(window.reverbDelay3);
          
          // Reverb output to mix
          window.reverbDelay1.connect(window.reverbMix);
          window.reverbDelay2.connect(window.reverbMix);
          window.reverbDelay3.connect(window.reverbMix);
          window.reverbMix.connect(window.distanceGain);
          
          // Final output
          window.distanceGain.connect(spatialAudioContext.destination);
          
          // Store reverb input for dynamic control
          window.reverbInputGain = reverbInput;
          
          // Initial settings: centered pan, full gain (self audio), no reverb
          window.stereoPanner.pan.value = 0;
          window.distanceGain.gain.value = 1.0; // Full volume for self audio
          window.reverbInputGain.gain.value = 0; // No reverb initially (self audio)
          
          isSpatialAudioEnabled = true;
          console.log('[SpatialAudio] Processor initialized with MediaStream');
          console.log('[SpatialAudio] Audio pipeline connected - self audio playing');
          console.log('[SpatialAudio] Using background-audio-post-processing.js + spatial-audio-processor.js');
          
          // Update listener position (self particle at origin)
          if (spatialProcessor) {
            spatialProcessor.updateListenerPosition({ x: 0, y: 0, z: 0 });
          }
          
          // Note: Self audio is now playing through the spatial pipeline
          // updateSpatialAudioPositions will adjust pan/gain based on particle positions
        } catch (err) {
          console.error('[SpatialAudio] Failed to initialize:', err);
          isSpatialAudioEnabled = false;
        }
      }
      
      // Update spatial audio positions (called from background audio processing)
      // This applies modular post-processing using Web Audio API for actual spatialization
      function updateSpatialAudioPositions(backgroundAudioState, selfParticle, particles) {
        // Check if spatial audio is enabled and nodes are initialized
        if (!isSpatialAudioEnabled || !window.stereoPanner || !window.distanceGain) {
          return; // Not enabled yet or nodes not initialized
        }
        
        // Update listener position (self particle at origin for relative positioning)
        if (spatialProcessor && selfParticle) {
          spatialProcessor.updateListenerPosition({
            x: selfParticle.position.x,
            y: selfParticle.position.y,
            z: 0
          });
        }
        
        // Apply spatialization from modular post-processing system
        // Use background-audio-post-processing.js calculated values
        const candidates = backgroundAudioState.localization?.candidates || [];
        
        // IMPORTANT: When candidates are present, we're hearing background audio from other users
        // This should have reverb to distinguish from self audio
        if (candidates.length > 0) {
          // Use the closest candidate's panning and gain to adjust the overall mix
          const primaryCandidate = candidates[0]; // Already sorted by distance
          
          // Apply panning (from calculateLocalization in background-audio-post-processing.js)
          // This pans the entire mix based on the closest particle's position
          // Use more extreme panning for better directional perception (-1 to 1 full range)
          let targetPan = primaryCandidate.pan || 0;
          
          // Make panning more extreme: amplify the pan value and clamp to -1 to 1
          // This makes direction changes more noticeable and intuitive
          targetPan = Math.max(-1, Math.min(1, targetPan * 1.5)); // Amplify panning
          
          const currentPan = window.stereoPanner.pan.value;
          // Faster panning response for more intuitive direction perception
          const panDiff = targetPan - currentPan;
          const panSmoothing = 0.5; // Higher = faster response (was 0.15, now 0.5 for less lag)
          window.stereoPanner.pan.value = currentPan + panDiff * panSmoothing;
          
          // Apply distance-based gain (from calculateLocalization)
          // This adjusts overall volume based on distance to nearest particle
          // Note: Self audio is always present, this just adjusts based on interaction
          const targetGain = Math.min(1.0, 0.7 + (primaryCandidate.gain || 0) * 0.3); // 0.7-1.0 range
          const currentGain = window.distanceGain.gain.value;
          const gainDiff = targetGain - currentGain;
          const gainSmoothing = 0.15; // Faster gain response (was 0.1)
          window.distanceGain.gain.value = Math.max(0.5, Math.min(1.0, currentGain + gainDiff * gainSmoothing));
          
          // Enable reverb for background audio (other users' sounds)
          // OPTIMIZED: Only update reverb every 5 frames to reduce lag
          if (window._reverbUpdateCounter === undefined) window._reverbUpdateCounter = 0;
          window._reverbUpdateCounter++;
          
          if (window._reverbUpdateCounter % 5 === 0 && window.reverbMix && window.reverbInputGain) {
            const isOuter = primaryCandidate.isInOuter === 1 && primaryCandidate.isInDistinct === 0;
            const isInner = primaryCandidate.isInDistinct === 1;
            
            // Outer particles: more reverb (wet, distant feel)
            // Inner particles: moderate reverb (closer but still distinct)
            let targetReverbWetness = isOuter ? 0.6 : (isInner ? 0.4 : 0.3);
            
            // Increase reverb based on distance (further = more reverb)
            const distanceFactor = Math.min(1, primaryCandidate.distance / outerRadius);
            targetReverbWetness = Math.min(0.8, targetReverbWetness + distanceFactor * 0.2);
            
            const currentReverb = window.reverbMix.gain.value;
            const reverbDiff = targetReverbWetness - currentReverb;
            const reverbSmoothing = 0.3; // Faster smoothing since we update less frequently
            window.reverbMix.gain.value = Math.max(0, Math.min(0.8, currentReverb + reverbDiff * reverbSmoothing));
            
            // Also adjust reverb input gain (how much signal goes into reverb)
            window.reverbInputGain.gain.value = targetReverbWetness * 0.7; // Scale down input to prevent feedback
          }
          
          // Log for debugging (throttled)
          if (window._lastSpatialLog === undefined) window._lastSpatialLog = 0;
          const now = Date.now();
          if (now - window._lastSpatialLog > 1000) { // Log once per second
            const reverbLevel = window.reverbMix ? window.reverbMix.gain.value.toFixed(2) : 'N/A';
            console.log(`[SpatialAudio] Pan: ${targetPan.toFixed(2)}, Gain: ${targetGain.toFixed(2)}, Reverb: ${reverbLevel}, Distance: ${primaryCandidate.distance.toFixed(1)}px`);
            window._lastSpatialLog = now;
          }
        } else {
          // No nearby particles: center pan, full gain (self audio only), no reverb
          const targetPan = 0;
          const targetGain = 1.0; // Full volume when alone (self audio)
          const currentPan = window.stereoPanner.pan.value;
          const currentGain = window.distanceGain.gain.value;
          
          window.stereoPanner.pan.value = currentPan + (targetPan - currentPan) * 0.5; // Faster return to center
          window.distanceGain.gain.value = Math.max(0.5, currentGain + (targetGain - currentGain) * 0.15);
          
          // Disable reverb when alone (self audio is dry) - OPTIMIZED: Only update every 5 frames
          if (window._reverbUpdateCounter !== undefined && window._reverbUpdateCounter % 5 === 0) {
            if (window.reverbMix && window.reverbInputGain) {
              const currentReverb = window.reverbMix.gain.value;
              window.reverbMix.gain.value = Math.max(0, currentReverb - 0.2); // Faster fade out
              window.reverbInputGain.gain.value = Math.max(0, (window.reverbInputGain.gain.value || 0) - 0.2);
            }
          }
        }
      }
      
      // Listen for audio stream from NoiseCraft iframe
      window.addEventListener("message", (event) => {
        if (event.data?.type === "noiseCraft:audioStreamReady") {
          console.log("[Main] Received audio stream ready notification from NoiseCraft");
          
          // Access MediaStream directly from iframe window (MediaStream can't be transferred via postMessage)
          if (iframe && iframe.contentWindow) {
            try {
              // Wait a bit for the stream to be set on the iframe window
              setTimeout(() => {
                const iframeStream = iframe.contentWindow.noiseCraftMediaStream;
                const sampleRate = iframe.contentWindow.noiseCraftAudioContext?.sampleRate || event.data.audioContextSampleRate || 44100;
                
                if (iframeStream) {
                  console.log("[Main] Successfully accessed MediaStream from iframe");
                  initializeSpatialProcessor(iframeStream, sampleRate);
                } else {
                  console.warn("[Main] MediaStream not found on iframe window, retrying...");
                  // Retry after a short delay
                  setTimeout(() => {
                    const retryStream = iframe.contentWindow.noiseCraftMediaStream;
                    if (retryStream) {
                      initializeSpatialProcessor(retryStream, sampleRate);
                    } else {
                      console.error("[Main] Failed to access MediaStream from iframe");
                    }
                  }, 500);
                }
              }, 100);
            } catch (err) {
              console.error("[Main] Error accessing iframe MediaStream:", err);
            }
          }
        } else if (event.data?.type === "noiseCraft:audioStreamStopped") {
          console.log("[Main] Audio stream stopped");
          if (mediaStreamSource) {
            try {
              mediaStreamSource.disconnect();
            } catch (e) {}
            mediaStreamSource = null;
          }
          if (window.stereoPanner) {
            try {
              window.stereoPanner.disconnect();
            } catch (e) {}
            window.stereoPanner = null;
          }
          if (window.distanceGain) {
            try {
              window.distanceGain.disconnect();
            } catch (e) {}
            window.distanceGain = null;
          }
          isSpatialAudioEnabled = false;
        }
      });
      
      // Expose for debugging
      window.spatialAudioProcessor = {
        initialize: initializeSpatialProcessor,
        update: updateSpatialAudioPositions,
        enabled: () => isSpatialAudioEnabled && window.stereoPanner && window.distanceGain,
        processor: () => spatialProcessor,
        getState: () => ({
          enabled: isSpatialAudioEnabled,
          hasPanner: !!window.stereoPanner,
          hasGain: !!window.distanceGain,
          hasReverb: !!window.reverbMix
        })
      };
      
      const streamMapper = new StreamNodeMapper('glb_audio_map.ncft');

      // Node Browser - Load nodes from project file
      let availableNodes = [];
      async function loadProjectNodes() {
        try {
          const response = await fetch(
            "/public/examples/falling_in_love_with_waterfalls (2).ncft"
          );
          const projectData = await response.json();
          availableNodes = Object.entries(projectData.nodes || {}).map(
            ([id, node]) => ({
              id,
              type: node.type || "Unknown",
              name: node.name || node.type || "Unnamed",
              params: node.params || {},
            })
          );
          // Filter to only Const and Knob types (single-value nodes)
          availableNodes = availableNodes.filter(
            (n) => n.type === "Knob" || n.type === "Const"
          );
          populateNodeSelectors();
        } catch (e) {
          console.warn("Failed to load project nodes:", e);
        }
      }

      function populateNodeSelectors() {
        document.querySelectorAll(".mapping-node-select").forEach((select) => {
          const currentValue = select
            .closest(".mapping-item")
            ?.querySelector(".mapping-node-id")?.value;
          const currentOptions = Array.from(select.options).map((o) => o.value);
          
          // Only populate if not already populated
          if (currentOptions.length === 1 && currentOptions[0] === "") {
            availableNodes.forEach((node) => {
              const option = document.createElement("option");
              option.value = node.id;
              option.textContent = `${node.id}: ${node.name} (${node.type})`;
              if (currentValue === node.id) option.selected = true;
              select.appendChild(option);
            });
          }
        });
      }

      // UI Elements
      const statusEl = document.getElementById("status");
      const btnStart = document.getElementById("btn_start");
      const btnStop = document.getElementById("btn_stop");
      const innerRadiusSlider = document.getElementById("inner-radius");
      const outerRadiusSlider = document.getElementById("outer-radius");
      const innerRadiusValue = document.getElementById("inner-radius-value");
      const outerRadiusValue = document.getElementById("outer-radius-value");
      const gSlider = document.getElementById("g-constant");
      const gValue = document.getElementById("g-value");
      const minDistSlider = document.getElementById("min-distance");
      const minDistValue = document.getElementById("min-dist-value");

      // Tab switching
      document.querySelectorAll(".tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          const targetTab = tab.dataset.tab;
          document.querySelectorAll(".tab").forEach((t) => t.classList.remove("active"));
          document.querySelectorAll(".tab-content").forEach((c) => c.classList.remove("active"));
          tab.classList.add("active");
          document.getElementById(`${targetTab}-tab`).classList.add("active");
        });
      });

      // Radius controls
      innerRadiusSlider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        signalGenerator.innerRadius = value;
        innerRadiusValue.textContent = value;
      });

      outerRadiusSlider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        signalGenerator.outerRadius = value;
        outerRadiusValue.textContent = value;
      });

      gSlider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        signalGenerator.G = value;
        gValue.textContent = value;
      });

      minDistSlider.addEventListener("input", (e) => {
        const value = parseInt(e.target.value);
        signalGenerator.minDistance = value;
        minDistValue.textContent = value;
      });

      // Create mapping UI
      function createMappingUI(mapping = null) {
        const mappingId = mapping?.id || `mapping-${Date.now()}`;
        const mappingDiv = document.createElement("div");
        mappingDiv.className = "mapping-item";
        mappingDiv.dataset.mappingId = mappingId;

        const streams = mapping?.streams || [{ stream: "attraction", interpolation: "linear", inputMin: 0, inputMax: 1, outputMin: 0, outputMax: 1 }];

        mappingDiv.innerHTML = `
          <div class="mapping-header">
            <h4>Node ${mapping?.nodeId || ""}</h4>
            <div>
              <input type="checkbox" ${mapping?.enabled !== false ? "checked" : ""} class="mapping-enabled" />
              <button class="remove-btn danger" onclick="removeMapping('${mappingId}')">Remove</button>
            </div>
          </div>
          <div class="mapping-controls">
            <div class="control-row">
              <span class="control-label">Node:</span>
              <div style="display: flex; gap: 4px;">
                <select class="mapping-node-select" style="flex: 1;">
                  <option value="">-- Select Node --</option>
                </select>
                <input type="text" class="mapping-node-id" value="${mapping?.nodeId || ""}" placeholder="ID" style="width: 60px; font-size: 11px;" />
                <button type="button" class="browse-node-btn" onclick="browseNodes('${mappingId}')" style="padding: 4px 8px; font-size: 10px;">Browse</button>
              </div>
            </div>
            <div class="control-row">
              <span class="control-label">Param:</span>
              <input type="text" class="mapping-param-name" value="${mapping?.paramName || "value"}" placeholder="value" />
            </div>
            <div class="control-row">
              <span class="control-label">Operation:</span>
              <select class="mapping-operation operation-select">
                ${OPERATIONS.map(op => `<option value="${op.value}" ${mapping?.operation === op.value ? "selected" : ""}>${op.label}</option>`).join("")}
              </select>
            </div>
            <div class="stream-inputs" data-streams-container>
              ${streams.map((stream, idx) => `
                <div class="stream-input-group" style="margin-bottom: 8px;">
                  <select class="stream-select">
                    ${AVAILABLE_STREAMS.map(s => `<option value="${s}" ${stream.stream === s ? "selected" : ""}>${s}</option>`).join("")}
                  </select>
                  <select class="stream-interpolation">
                    ${INTERPOLATION_MODES.map(m => `<option value="${m}" ${stream.interpolation === m ? "selected" : ""}>${m}</option>`).join("")}
                  </select>
                  <div class="range-inputs">
                    <input type="number" class="stream-input-min" placeholder="in min" step="0.01" value="${stream.inputMin || 0}" />
                    <input type="number" class="stream-input-max" placeholder="in max" step="0.01" value="${stream.inputMax || 1}" />
                  </div>
                  <div class="range-inputs">
                    <input type="number" class="stream-output-min" placeholder="out min" step="0.01" value="${stream.outputMin || 0}" />
                    <input type="number" class="stream-output-max" placeholder="out max" step="0.01" value="${stream.outputMax || 1}" />
                  </div>
                  ${streams.length > 1 ? `<button class="remove-btn danger" onclick="removeStream(this)">×</button>` : ""}
                </div>
              `).join("")}
            </div>
            <button class="add-stream-btn" onclick="addStream(this)">+ Add Stream</button>
          </div>
        `;

        return mappingDiv;
      }

      window.removeMapping = function(id) {
        streamMapper.removeMapping(id);
        document.querySelector(`[data-mapping-id="${id}"]`)?.remove();
      };

      window.addStream = function(btn) {
        const container = btn.previousElementSibling;
        const streamDiv = document.createElement("div");
        streamDiv.className = "stream-input-group";
        streamDiv.style.marginBottom = "8px";
        streamDiv.innerHTML = `
          <select class="stream-select">
            ${AVAILABLE_STREAMS.map(s => `<option value="${s}">${s}</option>`).join("")}
          </select>
          <select class="stream-interpolation">
            ${INTERPOLATION_MODES.map(m => `<option value="${m}">${m}</option>`).join("")}
          </select>
          <div class="range-inputs">
            <input type="number" class="stream-input-min" placeholder="in min" step="0.01" value="0" />
            <input type="number" class="stream-input-max" placeholder="in max" step="0.01" value="1" />
          </div>
          <div class="range-inputs">
            <input type="number" class="stream-output-min" placeholder="out min" step="0.01" value="0" />
            <input type="number" class="stream-output-max" placeholder="out max" step="0.01" value="1" />
          </div>
          <button class="remove-btn danger" onclick="removeStream(this)">×</button>
        `;
        container.appendChild(streamDiv);
      };

      window.removeStream = function(btn) {
        btn.closest(".stream-input-group")?.remove();
      };

      window.browseNodes = function(mappingId) {
        const mappingDiv = document.querySelector(`[data-mapping-id="${mappingId}"]`);
        if (!mappingDiv) return;
        
        // Enable browse mode - allows single-click node selection
        const iframe = document.getElementById("noisecraft-iframe");
        if (iframe && iframe.contentWindow) {
          // Set browse mode in iframe
          iframe.contentWindow.browseModeActive = true;
          iframe.contentWindow.browseModeMappingId = mappingId;
          
          // Update UI to show browse mode is active
          const browseBtn = mappingDiv.querySelector(".browse-node-btn");
          if (browseBtn) {
            browseBtn.textContent = "Browse Mode Active - Click a node";
            browseBtn.style.background = "#4a8";
            browseBtn.disabled = true;
          }
          
          statusEl.textContent = "Browse mode active: Click a node in the NoiseCraft editor to select it";
          
          // Disable browse mode after 30 seconds or when node is selected
          setTimeout(() => {
            if (iframe.contentWindow) {
              iframe.contentWindow.browseModeActive = false;
              iframe.contentWindow.browseModeMappingId = null;
            }
            if (browseBtn) {
              browseBtn.textContent = "Browse";
              browseBtn.style.background = "";
              browseBtn.disabled = false;
            }
            if (statusEl.textContent.includes("Browse mode")) {
              statusEl.textContent = "Ready. Click Start to begin.";
            }
          }, 30000);
        }
        
        // Show node browser modal or update selector
        const nodeSelect = mappingDiv.querySelector(".mapping-node-select");
        if (nodeSelect && nodeSelect.options.length === 1) {
          populateNodeSelectors();
        }
        nodeSelect?.focus();
      };

      // Save mapping when changed
      function attachMappingListeners(mappingDiv) {
        const mappingId = mappingDiv.dataset.mappingId;
        const nodeSelect = mappingDiv.querySelector(".mapping-node-select");
        const nodeIdInput = mappingDiv.querySelector(".mapping-node-id");
        const paramInput = mappingDiv.querySelector(".mapping-param-name");

        // Node selector dropdown
        if (nodeSelect) {
          nodeSelect.addEventListener("change", (e) => {
            const selectedId = e.target.value;
            if (selectedId) {
              nodeIdInput.value = selectedId;
              const selectedNode = availableNodes.find(
                (n) => n.id === selectedId
              );
              if (selectedNode) {
                // Auto-set param name if it's a Knob
                if (selectedNode.type === "Knob" && !paramInput.value) {
                  paramInput.value = "value";
                }
                // Update header
                const header = mappingDiv.querySelector("h4");
                if (header) {
                  header.textContent = `Node ${selectedId}: ${selectedNode.name}`;
                }
              }
              saveMapping(mappingId);
            }
          });
        }

        // Sync text input to dropdown
        if (nodeIdInput) {
          nodeIdInput.addEventListener("input", (e) => {
            const id = e.target.value;
            if (nodeSelect) {
              nodeSelect.value = id;
              const selectedNode = availableNodes.find((n) => n.id === id);
              if (selectedNode) {
                const header = mappingDiv.querySelector("h4");
                if (header) {
                  header.textContent = `Node ${id}: ${selectedNode.name}`;
                }
              }
            }
            saveMapping(mappingId);
          });
        }

        const inputs = mappingDiv.querySelectorAll("input, select");
        inputs.forEach((input) => {
          if (input !== nodeSelect && input !== nodeIdInput) {
            input.addEventListener("change", () => {
              saveMapping(mappingId);
            });
            input.addEventListener("input", () => {
              saveMapping(mappingId);
            });
          }
        });

        // Populate node selector
        if (nodeSelect) {
          populateNodeSelectors();
        }
      }

      function saveMapping(mappingId) {
        const mappingDiv = document.querySelector(`[data-mapping-id="${mappingId}"]`);
        if (!mappingDiv) return;

        const nodeId = mappingDiv.querySelector(".mapping-node-id").value;
        const paramName = mappingDiv.querySelector(".mapping-param-name").value;
        const operation = mappingDiv.querySelector(".mapping-operation").value;
        const enabled = mappingDiv.querySelector(".mapping-enabled").checked;

        const streams = Array.from(mappingDiv.querySelectorAll(".stream-input-group")).map((group) => ({
          stream: group.querySelector(".stream-select").value,
          interpolation: group.querySelector(".stream-interpolation").value,
          inputMin: parseFloat(group.querySelector(".stream-input-min").value) || 0,
          inputMax: parseFloat(group.querySelector(".stream-input-max").value) || 1,
          outputMin: parseFloat(group.querySelector(".stream-output-min").value) || 0,
          outputMax: parseFloat(group.querySelector(".stream-output-max").value) || 1,
        }));

        if (!nodeId) return;

        const existing = streamMapper.mappings.find((m) => m.id === mappingId);
        if (existing) {
          streamMapper.updateMapping(mappingId, {
            nodeId,
            paramName,
            operation,
            enabled,
            streams,
          });
        } else {
          streamMapper.addMapping({
            nodeId,
            paramName,
            operation,
            enabled,
            streams,
          });
        }
      }

      function renderMappings() {
        const container = document.getElementById("mappings-container");
        container.innerHTML = "";
        streamMapper.mappings.forEach((mapping) => {
          const mappingDiv = createMappingUI(mapping);
          container.appendChild(mappingDiv);
          attachMappingListeners(mappingDiv);
        });
      }

      document.getElementById("add-mapping-btn").addEventListener("click", () => {
        const mappingId = streamMapper.addMapping({
          nodeId: "",
          paramName: "value",
          operation: "none",
          enabled: true,
          streams: [
            {
              stream: "attraction",
              interpolation: "linear",
              inputMin: 0,
              inputMax: 1,
              outputMin: 0,
              outputMax: 1,
            },
          ],
        });
        renderMappings();
      });

      // Export mappings button
      document.getElementById("export-mappings-btn").addEventListener("click", () => {
        streamMapper.exportMappings();
        statusEl.textContent = `Exported ${streamMapper.mappings.length} mappings`;
        setTimeout(() => {
          if (statusEl.textContent.includes("Exported")) {
            statusEl.textContent = "Ready. Click Start to begin.";
          }
        }, 2000);
      });

      // Import mappings button
      const importFileInput = document.getElementById("import-file-input");
      document.getElementById("import-mappings-btn").addEventListener("click", () => {
        importFileInput.click();
      });
      
      importFileInput.addEventListener("change", async (e) => {
        const file = e.target.files[0];
        if (file) {
          const success = await streamMapper.importMappings(file);
          if (success) {
            renderMappings();
            statusEl.textContent = `Imported ${streamMapper.mappings.length} mappings`;
            setTimeout(() => {
              if (statusEl.textContent.includes("Imported")) {
                statusEl.textContent = "Ready. Click Start to begin.";
              }
            }, 2000);
          } else {
            statusEl.textContent = "Failed to import mappings";
            setTimeout(() => {
              if (statusEl.textContent.includes("Failed")) {
                statusEl.textContent = "Ready. Click Start to begin.";
              }
            }, 3000);
          }
        }
        // Reset file input
        importFileInput.value = '';
      });

      // NoiseCraft integration - ready flag (iframe already declared above)
      let noisecraftReady = false;
      
      // Initialize animation variables early
      let lastTime = Date.now();
      let animationFrame = null;
      
      // Initialize throttling variables
      let lastSignalUpdate = 0;
      let lastParamUpdate = 0;
      const SIGNAL_UPDATE_INTERVAL = 16; // ~60fps for signal updates
      const PARAM_UPDATE_INTERVAL = 33; // ~30fps for parameter updates (less critical)
      const SEQUENCER_UPDATE_THROTTLE = 100; // Only update sequencers every 100ms max
      
      // Parameter smoothing to prevent clicks/pops from rapid changes
      const paramSmoothing = new Map(); // nodeId:paramName -> {current, target, smoothing}
      const SMOOTHING_FACTOR = 0.1; // Lower = smoother but slower response (0.1 = ~90ms smoothing)
      
      function smoothParameter(nodeId, paramName, targetValue, smoothingFactor = SMOOTHING_FACTOR) {
        const key = `${nodeId}:${paramName}`;
        const current = paramSmoothing.get(key) || { current: targetValue, target: targetValue };
        
        // Update target
        current.target = targetValue;
        
        // Smooth towards target using exponential smoothing
        const diff = current.target - current.current;
        current.current += diff * smoothingFactor;
        
        paramSmoothing.set(key, current);
        return current.current;
      }
      
      function sendToNoiseCraft(params) {
        if (!iframe || !noisecraftReady || !params.length) return;
        
        // Apply smoothing to all parameters to prevent clicks/pops
        const smoothedParams = params.map(param => {
          const smoothedValue = smoothParameter(param.nodeId, param.paramName, param.value);
          return {
            ...param,
            value: smoothedValue
          };
        });
        
        iframe.contentWindow?.postMessage(
          { type: "noiseCraft:setParams", params: smoothedParams },
          "*"
        );
      }

      // Scope visualization data for all particles
      const scopeData = {
        0: { attraction: [], velocity: [], maxLength: 200 },
        1: { attraction: [], velocity: [], maxLength: 200 },
        2: { attraction: [], velocity: [], maxLength: 200 },
      };

      // Scope visualization functions
      function drawScope(canvasId, data, label) {
        const canvas = document.getElementById(canvasId);
        if (!canvas) return;
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, width, height);
        
        if (data.length < 2) return;
        
        ctx.strokeStyle = "#4a8";
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const stepX = width / (data.length - 1);
        const midY = height / 2;
        const scaleY = height * 0.4;
        
        data.forEach((value, i) => {
          const x = i * stepX;
          const y = midY - (value * scaleY);
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });
        
        ctx.stroke();
        
        // Draw center line
        ctx.strokeStyle = "#444";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, midY);
        ctx.lineTo(width, midY);
        ctx.stroke();
        
        // Draw label
        ctx.fillStyle = "#aaa";
        ctx.font = "10px monospace";
        ctx.fillText(label, 4, 12);
      }

      // Update animation loop - optimized with throttling
      function update(dt) {
        try {
          if (!particleSystem) {
            console.error("Particle system not initialized!");
            return;
          }
          
          // Update particle system (handles all physics) - always update for smooth physics
          particleSystem.update(dt);
          
          // Get fresh particles reference
          const particles = particleSystem.getParticles();
          
          if (!particles || particles.length === 0) {
            // Log detailed debug info when particles disappear
            console.error("⚠️ No particles found in system!");
            console.error("  particleSystem:", particleSystem);
            console.error("  signalGenerator:", particleSystem?.signalGenerator);
            console.error("  signalGenerator.particles:", particleSystem?.signalGenerator?.particles);
            console.error("  getParticles() returned:", particles);
            
            // Try to reinitialize particles if they're missing
            if (particleSystem && particleSystem.signalGenerator && 
                (!particleSystem.signalGenerator.particles || particleSystem.signalGenerator.particles.length === 0)) {
              console.warn("⚠️ Attempting to reinitialize particles...");
              // Don't reinitialize here - let the user know there's a problem
            }
            
            // Draw empty canvas
            const canvas = document.getElementById("particle-canvas");
            if (canvas) {
              const ctx = canvas.getContext("2d");
              ctx.fillStyle = "#0a0a0a";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.fillStyle = "#f44";
              ctx.font = "14px monospace";
              ctx.fillText("No particles detected", 10, canvas.height / 2);
              ctx.fillStyle = "#aaa";
              ctx.font = "10px monospace";
              ctx.fillText("Check console for details", 10, canvas.height / 2 + 20);
            }
            return;
          }

          const now = Date.now();
          
          // Throttle signal generation and UI updates (60fps max)
          if (now - lastSignalUpdate >= SIGNAL_UPDATE_INTERVAL) {
            lastSignalUpdate = now;
            
            // Generate signals for all particles and update UI
            particles.forEach((particle) => {
              const signals = particleSystem.generateSignals(particle.id);
              if (signals) {
                const pid = particle.id;
                
                // Batch DOM updates
                const attractionEl = document.getElementById(`signal-attraction-${pid}`);
                const velocityEl = document.getElementById(`signal-velocity-${pid}`);
                const distanceEl = document.getElementById(`signal-distance-${pid}`);
                const closingEl = document.getElementById(`signal-closing-${pid}`);
                const innerEl = document.getElementById(`signal-inner-${pid}`);
                const outerEl = document.getElementById(`signal-outer-${pid}`);
                
                if (attractionEl) attractionEl.textContent = signals.attraction.toFixed(3);
                if (velocityEl) velocityEl.textContent = signals.velocity.toFixed(3);
                if (distanceEl) {
                  distanceEl.textContent = signals.distance === Infinity
                    ? "∞"
                    : Math.round(signals.distance).toString();
                }
                if (closingEl) closingEl.textContent = signals.closingSpeed.toFixed(3);
                if (innerEl) innerEl.textContent = signals.isInner.toString();
                if (outerEl) outerEl.textContent = signals.isOuter.toString();

                // Update scope data
                scopeData[pid].attraction.push(signals.attraction);
                scopeData[pid].velocity.push(signals.velocity);
                
                if (scopeData[pid].attraction.length > scopeData[pid].maxLength) {
                  scopeData[pid].attraction.shift();
                }
                if (scopeData[pid].velocity.length > scopeData[pid].maxLength) {
                  scopeData[pid].velocity.shift();
                }
                
                // Draw scopes
                drawScope(`scope-attraction-${pid}`, scopeData[pid].attraction, `Attraction: ${signals.attraction.toFixed(3)}`);
                drawScope(`scope-velocity-${pid}`, scopeData[pid].velocity, `Velocity: ${signals.velocity.toFixed(3)}`);
              }
            });
          }
          
          // Draw particle visualizations (can run at full frame rate for smooth visuals)
          drawParticles();
          drawIndividualView();

          // Throttle parameter updates (30fps max - audio params don't need 60fps)
          if (now - lastParamUpdate >= PARAM_UPDATE_INTERVAL) {
            lastParamUpdate = now;
            
            // Generate parameters from mappings for all particles
            // For now, use particle 0 for parameter mapping (individual audio control)
            const signals0 = particleSystem.generateSignals(0);
            if (signals0) {
              const params = streamMapper.generateParams(signals0);
            
              // Distance-based volume control: fade out other particles as they get far
              // When particles are beyond outerRadius, only self is audible
              const config = particleSystem.getConfig();
              const outerRadius = config.outerRadius || 150;
              const innerRadius = config.innerRadius || 80;
              
              // ===== BACKGROUND AUDIO POST-PROCESSING =====
              // Use the dedicated post-processing module (HTML-independent, reusable in backend)
              const particles = particleSystem.getParticles();
              const selfParticle = particles.find(p => p.id === 0);
              
              const backgroundAudio = processBackgroundAudio(
                selfParticle,
                particles,
                {
                  innerRadius,
                  outerRadius,
                  baseVolume: 0.0015
                }
              );
              
              // Merge background audio params with existing params
              backgroundAudio.params.forEach(bgParam => {
                const existingParam = params.find(p => 
                  p.nodeId === bgParam.nodeId && p.paramName === bgParam.paramName
                );
                if (existingParam) {
                  existingParam.value = bgParam.value;
                } else {
                  params.push(bgParam);
                }
              });
              
              // Store localization state for potential future use
              if (!window.backgroundAudioState) window.backgroundAudioState = {};
              window.backgroundAudioState = backgroundAudio.state;
              
              // ===== MODULAR AUDIO SYSTEM: Apply Web Audio API Spatialization =====
              // Use the modular post-processing system instead of just NoiseCraft node parameters
              // This provides actual spatial audio (panning, distance-based gain, reverb) using Web Audio API
              if (window.spatialAudioProcessor && window.spatialAudioProcessor.enabled() && isSpatialAudioEnabled) {
                window.spatialAudioProcessor.update(backgroundAudio.state, selfParticle, particles);
              } else {
                // Fallback: If Web Audio API spatialization is not available yet,
                // still use NoiseCraft node parameters (but this is less effective)
                // Only warn once to avoid spam
                if (!window._spatialWarningShown) {
                  console.warn('[Audio] Web Audio API spatialization not enabled, using NoiseCraft node parameters');
                  window._spatialWarningShown = true;
                }
              }
              
              sendToNoiseCraft(params);
              
              // Store signals in global scope for sequencer logic access
              if (!window.particleSignals) window.particleSignals = {};
              window.particleSignals[0] = signals0;
              
              // Update sequencer patterns when inner particles change
              const currentInnerParticleIds = new Set(
                signals0.innerParticles ? signals0.innerParticles.map(p => p.id) : []
              );
              
              // Check if inner particles changed
              const innerParticlesChanged = 
                currentInnerParticleIds.size !== previousInnerParticleIds.size ||
                [...currentInnerParticleIds].some(id => !previousInnerParticleIds.has(id)) ||
                [...previousInnerParticleIds].some(id => !currentInnerParticleIds.has(id));
              
              // ALWAYS update sequencer patterns, not just when innerParticles change
              // This ensures baritone/tenor are cleared when particle becomes alone
              if (iframe && iframe.contentWindow) {
                const selfParticle = particles.find(p => p.id === 0);
                if (selfParticle) {
                  // Convert innerParticles data to particle objects (may be empty array when alone)
                  const innerParticleObjects = signals0.innerParticles 
                    ? signals0.innerParticles.map(pData => 
                        particles.find(p => p.id === pData.id)
                      ).filter(p => p !== undefined)
                    : [];
                  
                  // Generate individual sequencer pattern
                  // When alone: only bass has note, baritone/tenor are all zeros
                  // When with inner particles: bass + baritone (+ tenor) have notes
                  const sequencerPattern = sequencerLogic.generateIndividualPattern(
                    selfParticle, 
                    innerParticleObjects
                  );
                  
                  // Check if pattern actually changed
                  const patternChanged = !previousSequencerPattern || 
                    JSON.stringify(sequencerPattern) !== JSON.stringify(previousSequencerPattern);
                  
                  // Always update when pattern changes OR when inner particles change
                  // This ensures we clear baritone/tenor when particle becomes alone
                  if (patternChanged || innerParticlesChanged) {
                    const isAlone = innerParticleObjects.length === 0;
                    console.log(`[Sequencer] Updating patterns - ${isAlone ? 'ALONE (single tone)' : `CHORD (${innerParticleObjects.length + 1} notes)`}:`, sequencerPattern);
                    
                    // Update each sequencer (bass, baritone, tenor) - optimized with requestAnimationFrame
                    // Use 12-step arpeggiator patterns
                    requestAnimationFrame(() => {
                      // Update sequencers with arpeggiator patterns (12 steps x 12 rows)
                      // Each voice uses all available notes, creating independent arpeggiator patterns
                      updateMonoSeqSequencer(
                        iframe.contentWindow,
                        SEQUENCER_NODES.individual.bass,
                        0, // pattern index
                        sequencerPattern.bass, // Arpeggiator pattern: [step0[row0...row11], step1[...], ...]
                        12  // numSteps: 12 steps for arpeggiator
                      );
                      
                      updateMonoSeqSequencer(
                        iframe.contentWindow,
                        SEQUENCER_NODES.individual.baritone,
                        0,
                        sequencerPattern.baritone, // Arpeggiator pattern
                        12  // numSteps: 12 steps
                      );
                      
                      updateMonoSeqSequencer(
                        iframe.contentWindow,
                        SEQUENCER_NODES.individual.tenor,
                        0,
                        sequencerPattern.tenor, // Arpeggiator pattern
                        12  // numSteps: 12 steps
                      );
                    });
                    
                    previousSequencerPattern = JSON.parse(JSON.stringify(sequencerPattern));
                  }
                }
                
                previousInnerParticleIds = new Set(currentInnerParticleIds);
              }
            }
          }
        } catch (updateError) {
          console.error("Update loop error:", updateError);
          console.error("Stack:", updateError.stack);
        }
      }
      
      // Global view visualization - fixed bounds centered on center of mass
      function drawParticles() {
        const canvas = document.getElementById("particle-canvas");
        if (!canvas || !particleSystem) return;
        const particles = particleSystem.getParticles();
        if (!particles || particles.length === 0) return;
        
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, width, height);
        
        // Calculate center of mass for stable reference
        let totalMass = 0;
        let cmX = 0, cmY = 0;
        particles.forEach(p => {
          totalMass += p.mass || 1;
          cmX += (p.position.x * (p.mass || 1));
          cmY += (p.position.y * (p.mass || 1));
        });
        cmX /= totalMass;
        cmY /= totalMass;
        
        // Fixed bounds centered on center of mass (±400px view range - large enough to keep all particles visible)
        const viewRange = 400;
        const minX = cmX - viewRange;
        const maxX = cmX + viewRange;
        const minY = cmY - viewRange;
        const maxY = cmY + viewRange;
        
        const rangeX = maxX - minX;
        const rangeY = maxY - minY;
        const scale = Math.min(width / rangeX, height / rangeY);
        
        const config = particleSystem.getConfig();
        
        // Draw grid center marker (center of mass)
        const centerX = (cmX - minX) * scale;
        const centerY = (cmY - minY) * scale;
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(centerX - 10, centerY);
        ctx.lineTo(centerX + 10, centerY);
        ctx.moveTo(centerX, centerY - 10);
        ctx.lineTo(centerX, centerY + 10);
        ctx.stroke();
        
        // Draw connections (forces between particles)
        particles.forEach((p1, i) => {
          particles.forEach((p2, j) => {
            if (i < j) {
              const dx = p2.position.x - p1.position.x;
              const dy = p2.position.y - p1.position.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              
              // Draw connection if within outer radius
              if (distance <= config.outerRadius) {
                const x1 = (p1.position.x - minX) * scale;
                const y1 = (p1.position.y - minY) * scale;
                const x2 = (p2.position.x - minX) * scale;
                const y2 = (p2.position.y - minY) * scale;
                
                // Color based on distance
                const alpha = Math.max(0.1, 1 - distance / config.outerRadius);
                ctx.strokeStyle = `rgba(100, 150, 255, ${alpha * 0.5})`;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
              }
            }
          });
        });
        
        // Draw particles
        particles.forEach((p, i) => {
          const x = (p.position.x - minX) * scale;
          const y = (p.position.y - minY) * scale;
          
          // Draw particle (larger for central heavy particle)
          const radius = i === 0 ? 10 : 6;
          ctx.fillStyle = i === 0 ? "#4a8" : i === 1 ? "#a84" : "#8a4";
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fill();
          
          // Draw velocity vector
          ctx.strokeStyle = "#666";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + p.velocity.x * 2, y + p.velocity.y * 2);
          ctx.stroke();
          
          // Draw ID label
          ctx.fillStyle = "#aaa";
          ctx.font = "10px monospace";
          ctx.fillText(`P${i}`, x + radius + 2, y - 8);
        });
      }
      
      // Individual view visualization - perspective from one particle
      let controlledParticleId = 1; // Default: moon 1
      let isDragging = false;
      let dragStartPos = null;
      
      function drawIndividualView() {
        const canvas = document.getElementById("individual-canvas");
        if (!canvas || !particleSystem) return;
        const particles = particleSystem.getParticles();
        if (!particles || particles.length === 0) return;
        
        const selfParticle = particles.find(p => p.id === controlledParticleId);
        if (!selfParticle) return;
        
        const ctx = canvas.getContext("2d");
        const width = canvas.width;
        const height = canvas.height;
        
        // Clear canvas
        ctx.fillStyle = "#0a0a0a";
        ctx.fillRect(0, 0, width, height);
        
        // Center view on the controlled particle
        const centerX = width / 2;
        const centerY = height / 2;
        const viewRange = 150; // View distance in world coordinates
        const scale = Math.min(width, height) / (viewRange * 2);
        
        const config = particleSystem.getConfig();
        
        // Draw radius rings for visual reference
        const innerRadiusPx = config.innerRadius * scale;
        const outerRadiusPx = config.outerRadius * scale;
        
        // Outer radius ring (audio cue range)
        ctx.strokeStyle = "rgba(150, 150, 255, 0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(centerX, centerY, outerRadiusPx, 0, Math.PI * 2);
        ctx.stroke();
        
        // Inner radius ring (distinct range)
        ctx.strokeStyle = "rgba(100, 255, 100, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(centerX, centerY, innerRadiusPx, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw center marker (self particle position) - always visible
        ctx.fillStyle = "#a84";
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        ctx.fill();
        
        // Add glowing outer ring for self particle
        const gradient = ctx.createRadialGradient(centerX, centerY, 8, centerX, centerY, 15);
        gradient.addColorStop(0, "rgba(170, 132, 68, 0.8)");
        gradient.addColorStop(1, "rgba(170, 132, 68, 0)");
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw other particles relative to self
        particles.forEach((p, i) => {
          if (p.id === controlledParticleId) return; // Skip self
          
          const dx = p.position.x - selfParticle.position.x;
          const dy = p.position.y - selfParticle.position.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          // Only draw if within view range
          if (distance > viewRange) return;
          
          const x = centerX + dx * scale;
          const y = centerY + dy * scale;
          
          const isInDistinct = distance <= config.innerRadius;
          const isInOuter = distance <= config.outerRadius && !isInDistinct;
          
          // Visual feedback: Glowing add layer when in outer range (overlapped area)
          if (isInOuter) {
            // Draw glowing overlay for outer range
            const outerGradient = ctx.createRadialGradient(x, y, 5, x, y, 12);
            outerGradient.addColorStop(0, `rgba(100, 150, 255, ${0.4 * (1 - distance / config.outerRadius)})`);
            outerGradient.addColorStop(1, "rgba(100, 150, 255, 0)");
            ctx.fillStyle = outerGradient;
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, Math.PI * 2);
            ctx.fill();
          }
          
          // Draw connection line only in distinct range (visible connection)
          if (isInDistinct) {
            // Bright visible connection line for distinct range
            ctx.strokeStyle = `rgba(100, 255, 100, ${0.8 * (1 - distance / config.innerRadius)})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(x, y);
            ctx.stroke();
          }
          
          // Draw particle (only visible in distinct range, or with glow in outer range)
          const radius = p.mass > 100 ? 8 : 5;
          if (isInDistinct || isInOuter) {
            ctx.fillStyle = p.id === 0 ? "#4a8" : "#8a4";
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, Math.PI * 2);
            ctx.fill();
            
            // Distinct range: add brighter outline
            if (isInDistinct) {
              ctx.strokeStyle = `rgba(100, 255, 100, 0.8)`;
              ctx.lineWidth = 2;
              ctx.beginPath();
              ctx.arc(x, y, radius + 2, 0, Math.PI * 2);
              ctx.stroke();
            }
            
            // Draw relative velocity vector
            const relVx = p.velocity.x - selfParticle.velocity.x;
            const relVy = p.velocity.y - selfParticle.velocity.y;
            ctx.strokeStyle = "#666";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + relVx * 2, y + relVy * 2);
            ctx.stroke();
            
            // Draw ID label
            ctx.fillStyle = "#aaa";
            ctx.font = "10px monospace";
            ctx.fillText(`P${i}`, x + radius + 2, y - 8);
          }
        });
        
        // Draw drag preview if dragging
        if (isDragging && dragStartPos) {
          ctx.strokeStyle = "rgba(255, 200, 0, 0.5)";
          ctx.lineWidth = 2;
          ctx.setLineDash([5, 5]);
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(dragStartPos.x, dragStartPos.y);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // Draw velocity preview arrow
          const dx = dragStartPos.x - centerX;
          const dy = dragStartPos.y - centerY;
          const angle = Math.atan2(dy, dx);
          const length = Math.min(50, Math.sqrt(dx * dx + dy * dy));
          const arrowX = centerX + Math.cos(angle) * length;
          const arrowY = centerY + Math.sin(angle) * length;
          
          ctx.fillStyle = "rgba(255, 200, 0, 0.3)";
          ctx.beginPath();
          ctx.moveTo(arrowX, arrowY);
          ctx.lineTo(
            arrowX - Math.cos(angle - Math.PI / 6) * 8,
            arrowY - Math.sin(angle - Math.PI / 6) * 8
          );
          ctx.lineTo(
            arrowX - Math.cos(angle + Math.PI / 6) * 8,
            arrowY - Math.sin(angle + Math.PI / 6) * 8
          );
          ctx.closePath();
          ctx.fill();
        }
      }
      
      // Drag controls for individual view
      function setupIndividualViewControls() {
        const canvas = document.getElementById("individual-canvas");
        if (!canvas || !particleSystem) return;
        
        const MAX_VELOCITY = 100; // Maximum velocity from drag
        
        canvas.addEventListener("mousedown", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          // Check if click is near center (within 20px)
          const dx = x - centerX;
          const dy = y - centerY;
          const dist = Math.sqrt(dx * dx + dy * dy);
          
          if (dist < 20) {
            isDragging = true;
            dragStartPos = { x, y };
            canvas.style.cursor = "crosshair";
          }
        });
        
        canvas.addEventListener("mousemove", (e) => {
          const rect = canvas.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          
          if (isDragging) {
            // Continuously update velocity based on cursor position relative to center
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx);
            
            // Map distance to velocity (0 to MAX_VELOCITY)
            // Use a portion of view range for max velocity (e.g., 70% for smoother control)
            const viewRange = 150;
            const maxControlRange = viewRange * 0.7;
            const scale = MAX_VELOCITY / maxControlRange;
            const velocity = Math.min(MAX_VELOCITY, distance * scale);
            
            // Apply velocity to controlled particle continuously
            const particles = particleSystem.getParticles();
            const particle = particles.find(p => p.id === controlledParticleId);
            if (particle) {
              particle.velocity.x = Math.cos(angle) * velocity;
              particle.velocity.y = Math.sin(angle) * velocity;
            }
            
            // Update drag position for visual feedback
            dragStartPos = { x, y };
          }
        });
        
        canvas.addEventListener("mouseup", (e) => {
          if (!isDragging) return;
          
          // Velocity is already set by mousemove, just clean up
          isDragging = false;
          dragStartPos = null;
          canvas.style.cursor = "crosshair";
        });
        
        canvas.addEventListener("mouseleave", () => {
          isDragging = false;
          dragStartPos = null;
          canvas.style.cursor = "crosshair";
        });
      }

      function animate() {
        try {
          const now = Date.now();
          const dt = Math.min((now - lastTime) / 1000, 0.1);
          lastTime = now;
          update(dt);
          animationFrame = requestAnimationFrame(animate);
        } catch (error) {
          console.error("Animation loop error:", error);
          console.error("Stack:", error.stack);
          // Restart animation loop after error
          setTimeout(() => {
            animationFrame = requestAnimationFrame(animate);
          }, 100);
        }
      }
      
      // NoiseCraft iframe setup (iframe already declared above)
      if (iframe) {
        iframe.addEventListener("load", async () => {
          statusEl.textContent = "Ready. Click Start to begin.";
          noisecraftReady = true;
          await loadProjectNodes();
          
          // Load mappings from project file (if embedded) or localStorage
          await streamMapper.loadMappings();
          renderMappings();
          
          // Enable auto-save for glb_audio_map.ncft when iframe is ready
          if (iframe.contentWindow) {
            // Small delay to ensure iframe message handler is ready
            setTimeout(() => {
              iframe.contentWindow.postMessage({
                type: "noiseCraft:enableAutoSave",
                enabled: true,
                filename: "glb_audio_map.ncft"
              }, "*");
              console.log("Auto-save enabled for glb_audio_map.ncft");
            }, 500);
          }
        });
      } else {
        console.error("NoiseCraft iframe not found!");
      }

      window.addEventListener("message", (event) => {
        if (event.data?.type === "noiseCraft:audioState") {
          if (event.data.status === "playing") {
            btnStart.style.display = "none";
            btnStop.style.display = "inline-block";
            statusEl.textContent = "Playing";
          } else if (event.data.status === "stopped") {
            btnStart.style.display = "inline-block";
            btnStop.style.display = "none";
            statusEl.textContent = "Stopped";
          }
        } else if (event.data?.type === "noiseCraft:saveStatus") {
          // Handle save status updates from iframe
          if (event.data.status === "saved") {
            console.log(`✓ Auto-saved ${event.data.filename}`);
            // When project is saved, we should embed mappings into it
            // Note: Mappings are loaded from project file on load, so they persist
            // Save mappings to localStorage as backup
            streamMapper.saveToStorage();
          } else if (event.data.status === "error") {
            const errorMsg = event.data.error || "Unknown error";
            console.warn(`✗ Failed to save ${event.data.filename}:`, errorMsg);
          }
        } else if (event.data?.type === "noiseCraft:requestMappings") {
          // Send current mappings to iframe for embedding in project
          iframe.contentWindow.postMessage({
            type: "noiseCraft:mappings",
            mappings: streamMapper.mappings
          }, "*");
        } else if (event.data?.type === "noiseCraft:projectLoaded") {
          // Project loaded, try to load mappings from it
          if (event.data.projectData) {
            const projectMappings = streamMapper.storage.loadFromProjectFile(event.data.projectData);
            if (projectMappings && projectMappings.length > 0) {
              streamMapper.mappings = projectMappings;
              renderMappings();
              console.log(`Loaded ${projectMappings.length} mappings from project file`);
            }
          }
        } else if (event.data?.type === "noiseCraft:nodeSelection") {
          // Handle node selection from NoiseCraft editor
          console.log("Node selection received:", event.data);
          
          // Extract data from event with safe defaults - declare all variables at once
          const eventData = event.data || {};
          const nodeIds = Array.isArray(eventData.nodeIds) ? eventData.nodeIds : [];
          const nodeType = eventData.nodeType || null;
          const nodeName = eventData.nodeName || null;
          
          // Only allow Const and Knob nodes
          if (nodeType && nodeType !== 'Const' && nodeType !== 'Knob') {
            console.log(`Node type ${nodeType} is not selectable. Only Const and Knob nodes can be mapped.`);
            return;
          }
          
          if (nodeIds.length > 0) {
            const firstNodeId = String(nodeIds[0]);
            const displayType = nodeType || 'unknown';
            const displayName = nodeName || 'unnamed';
            console.log(`Processing node selection: ID=${firstNodeId}, type=${displayType}, name=${displayName}`);
            
            let selectedNode = availableNodes.find((n) => n.id === firstNodeId);
            
            // If node not in availableNodes, create entry from selection data
            if (!selectedNode && nodeType && (nodeType === 'Const' || nodeType === 'Knob')) {
              selectedNode = {
                id: firstNodeId,
                type: nodeType,
                name: nodeName || nodeType,
                params: {},
              };
              console.log(`Created new node entry:`, selectedNode);
            }
            
            // Check if browse mode is active - ONLY process selection if browse mode is on
            const iframe = document.getElementById("noisecraft-iframe");
            let targetMappingId = null;
            let browseModeWasActive = false;
            
            if (iframe && iframe.contentWindow && iframe.contentWindow.browseModeMappingId) {
              targetMappingId = iframe.contentWindow.browseModeMappingId;
              browseModeWasActive = true;
              console.log(`Browse mode active, target mapping: ${targetMappingId}`);
              // Disable browse mode
              iframe.contentWindow.browseModeActive = false;
              iframe.contentWindow.browseModeMappingId = null;
            } else {
              // Browse mode is NOT active - ignore this selection
              console.log(`Node selection ignored - browse mode is not active`);
              return; // Exit early - don't update any mappings
            }
            
            // Only proceed if browse mode was active
            if (!browseModeWasActive || !targetMappingId) {
              console.log(`Skipping node selection - browse mode was not active`);
              return;
            }
            
            // Find the target mapping (only the one specified by browse mode)
            const targetMapping = document.querySelector(`[data-mapping-id="${targetMappingId}"]`);
            
            if (targetMapping) {
              const nodeSelect = targetMapping.querySelector(".mapping-node-select");
              const nodeIdInput = targetMapping.querySelector(".mapping-node-id");
              const header = targetMapping.querySelector("h4");
              
              // Fill in node ID and name - do this first before any events
              if (nodeIdInput) {
                nodeIdInput.value = firstNodeId;
              }
              if (nodeSelect) {
                nodeSelect.value = firstNodeId;
              }
              if (header) {
                if (selectedNode) {
                  header.textContent = `Node ${firstNodeId}: ${selectedNode.name}`;
                } else {
                  header.textContent = `Node ${firstNodeId}`;
                }
              }
              
              // Force save the mapping immediately
              const mappingId = targetMapping.dataset.mappingId;
              if (mappingId) {
                // Save directly
                const enabled = targetMapping.querySelector(".mapping-enabled")?.checked !== false;
                const paramName = targetMapping.querySelector(".mapping-param-name")?.value || "value";
                const operation = targetMapping.querySelector(".mapping-operation")?.value || "none";
                const streams = Array.from(targetMapping.querySelectorAll(".stream-input-group")).map((group) => ({
                  stream: group.querySelector(".stream-select")?.value || "attraction",
                  interpolation: group.querySelector(".stream-interpolation")?.value || "linear",
                  inputMin: parseFloat(group.querySelector(".stream-input-min")?.value) || 0,
                  inputMax: parseFloat(group.querySelector(".stream-input-max")?.value) || 1,
                  outputMin: parseFloat(group.querySelector(".stream-output-min")?.value) || 0,
                  outputMax: parseFloat(group.querySelector(".stream-output-max")?.value) || 1,
                }));
                
                streamMapper.updateMapping(mappingId, {
                  nodeId: firstNodeId,
                  paramName,
                  operation,
                  enabled,
                  streams,
                });
              }
              
              // Update browse button if it exists
              const browseBtn = targetMapping.querySelector(".browse-node-btn");
              if (browseBtn) {
                browseBtn.textContent = "Browse";
                browseBtn.style.background = "";
                browseBtn.disabled = false;
              }
              
              // Trigger change event to update UI
              if (nodeSelect) {
                nodeSelect.dispatchEvent(new Event("change", { bubbles: true }));
              }
              if (nodeIdInput) {
                nodeIdInput.dispatchEvent(new Event("input", { bubbles: true }));
              }
            } else {
              // Target mapping not found - this shouldn't happen if browse mode was active
              console.warn(`Target mapping ${targetMappingId} not found, but browse mode was active`);
              // Don't create a new mapping - user must click Browse button first
            }
            
            // Highlight in status
            const nodeDisplayName = selectedNode ? ` (${selectedNode.name})` : "";
            statusEl.textContent = `Selected node: ${firstNodeId}${nodeDisplayName}`;
            setTimeout(() => {
              if (statusEl.textContent.includes("Selected node")) {
                statusEl.textContent = "Ready. Click Start to begin.";
              }
            }, 2000);
          }
        }
      });

      btnStart.addEventListener("click", () => {
        iframe.contentWindow?.postMessage({ type: "noiseCraft:play" }, "*");
      });

      btnStop.addEventListener("click", () => {
        iframe.contentWindow?.postMessage({ type: "noiseCraft:stop" }, "*");
      });

      // Setup individual view drag controls
      setupIndividualViewControls();
      
      // Start animation loop (variables already initialized above)
      console.log("Starting animation loop...");
      
      // Verify particle system before starting animation
      const initialParticles = particleSystem.getParticles();
      if (!initialParticles || initialParticles.length === 0) {
        console.error("CRITICAL: Particle system is empty before animation start!");
        console.error("Particle system:", particleSystem);
        console.error("Signal generator:", particleSystem.signalGenerator);
        console.error("Signal generator particles:", particleSystem.signalGenerator?.particles);
      } else {
        console.log(`✓ Animation starting with ${initialParticles.length} particles`);
      }
      
      animate();
      
      } catch (error) {
        console.error("CRITICAL ERROR in script initialization:", error);
        console.error("Stack trace:", error.stack);
        // Show error to user
        const statusEl = document.getElementById("status");
        if (statusEl) {
          statusEl.textContent = `Error: ${error.message}`;
          statusEl.style.color = "#f44";
        }
        // Also log to console for debugging
        console.error("Full error details:", error);
      }
    </script>
  </body>
</html>
